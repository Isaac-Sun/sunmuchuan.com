[{"title":"Python 笔记","url":"/2021/03/20/Python/","content":"注：笔记有相当一部分来源于菜鸟教程。\n0 Python 基础0.0 Python 之禅import this\n\nThe Zen of Python, by Tim Peters\nBeautiful is better than ugly. \nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren’t special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one– and preferably only one –obvious way to do it.\nAlthough that way may not be obvious at first unless you’re Dutch.\nNow is better than never.\nAlthough never is often better than right now.\nIf the implementation is hard to explain, it’s a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea – let’s do more of those!\n0.1 标识符\n\n第一个字符必须是字母或下划线 _\n由字母、数字和下划线组成\n对大小写敏感\n\n\n在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。\n0.2 关键字我们不能把关键字用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：\n&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\n\n0.3 注释Python 中单行注释以#开头，这一行此后的一切都会被忽略：\n# 这是一行注释\n\n多行注释可以用多个#号，或者三引号'''与\"\"\"括起来，后者往往是文档字符串：\n#第一行注释#第二行注释'''很多行注释'''\n\n0.4 行与缩进Python 特色之一就是使用缩进来表示代码块，而不需要使用大括号 {} 。\n缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。实例如下：\nif True:    print (\"True\")else:    print (\"False\")\n\nPython 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠\\来实现多行语句，例如：\ntotal = item_one + \\        item_two + \\        item_three\n\n在 [], {}, 或 () 中的多行语句，不需要使用反斜杠\\，例如：\ntotal = ['item_one', 'item_two', 'item_three',        'item_four', 'item_five']\n\nPython可以在同一行中使用多条语句，语句之间使用分号;分割，以下是一个简单的实例：\nimport keyword;    print(keyword.kwlist)\n\n\n技巧：print()函数 基本语法如下：\nprint(*objects, sep=' ', end='\\n', file=sys.stdout, flush=False)\n\n可以发现print()默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=''：\n&gt;&gt;&gt; print(123,end='')&gt;&gt;&gt; print(456,end='')123456\n\n要使得print()函数输出字符串时原样输出带有\\的转义字符，只需在字符串前加r：\n&gt;&gt;&gt; print(r'我是老狗\\n')我是老狗\\n\n\n在输入各种类型数据时通常需要使用str()函数来转换类型，但也可以使用所谓格式化字符串的方法：\n&gt;&gt;&gt; print('我家%s%d岁啦' % ('阿包',3))我家阿包3岁啦\n\n这种方法需要事先指定变量的类型。我们也可以使用更强大字符串的format()方法：\n&gt;&gt;&gt; print('我家{}{}岁啦'.format('阿包',3))我家阿包三岁啦\n\n这种方法可以调整变量的顺序，还可多次使用format()后的数据。\nformat()函数还可以使用字典或者列表作为参数：\n&gt;&gt;&gt; dog = {'name':'阿包','age':3}&gt;&gt;&gt; print('我家{name}{age}岁啦'.format(**dog))我家阿包3岁啦&gt;&gt;&gt; dog_list = ['阿包',3]&gt;&gt;&gt; print('我家{0[0]}{0[1]}岁啦'.format(dog_list))    # 0是必须的我家阿包3岁啦\n\n还可以向format()函数传入对象：\n&gt;&gt;&gt; class Dog():&gt;&gt;&gt;     def __init__(self,name,age):&gt;&gt;&gt;         self.name = name&gt;&gt;&gt;         self.age = age&gt;&gt;&gt; my_dog = Dog('阿包',3)&gt;&gt;&gt; print('我家{.name}{.age}岁啦'.format(my_dog))    # 0是可选的我家阿包3岁啦\n\n\n1 数据类型Python3 中有六个标准的数据类型：\n\n\nNumber（数字）\nString（字符串）\nList（列表）\nTuple（元组）\nSet（集合）\nDictionary（字典）\n\n\n其中，字符串、列表和元组都属于序列（sequence） 。\nPython3 的六个标准数据类型中：\n\n不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；\n可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。\n\n可以使用del语句删除一些对象引用：\ndel var1,var2,var3,...\n\n1.1 字符串字符串是用单引号''或双引号\"\"括起来的一系列字符。\n1.1.1 字符串的方法\n\n\n方法\n返回\n注释\n\n\n\nstr.title()\n标题化的字符串\n不改变字符串本身\n\n\nstr.upper()\n大写的字符串\n不改变字符串本身\n\n\nstr.lower()\n小写的字符串\n不改变字符串本身\n\n\nstr.strip([chars])\n删除字符串两边的chars字符序列\n默认删除空白字符，不改变字符串本身\n\n\nstr.lstrip([chars])\n删除字符串开头的chars字符序列\n默认删除空白字符，不改变字符串本身\n\n\nstr.rstrip([chars])\n删除字符串结尾的chars字符序列\n默认删除空白字符，不改变字符串本身\n\n\n1.1.2 字符串的操作用+来进行拼接，如：'我是'+'薛定谔的老狗'相当于'我是薛定谔的老狗'。\n用*来进行翻倍，如：'老狗'*2相当于老狗老狗。\n1.1.3 字符串强制转换str()可将参数强制转换为字符串型返回。\n1.2 数字1.2.1 整数 int\n\n\n运算\n符号\n例子\n结果\n注释\n\n\n\n加法\n+\n3+2\n5\n\n\n\n减法\n-\n3-2\n1\n\n\n\n乘法\n*\n3*2\n6\n\n\n\n除法\n/\n3/2\n1.5\n不能整除结果自动为浮点数\n\n\n取整除法\n//\n3//2\n1\n向下取整\n\n\n取模\n%\n3%2\n1\n\n\n\n乘方\n**\n3**2\n9\n\n\n\n下面是 Python 的赋值运算符：\n\n\n\n运算符\n名称\n注释\n\n\n\n=\n简单的赋值运算符\nc = a + b将a + b的运算结果赋值为c\n\n\n+=\n加法赋值运算符\nc += a等效于c = c + a\n\n\n-=\n减法赋值运算符\nc -= a等效于c = c - a\n\n\n*=\n乘法赋值运算符\nc *= a等效于c = c * a\n\n\n/=\n除法赋值运算符\nc /= a等效于c = c / a\n\n\n%=\n取模赋值运算符\nc %= a等效于c = c % a\n\n\n**=\n幂赋值运算符\nc **= a等效于c = c ** a\n\n\n//=\n取整除赋值运算符\nc //= a等效于c = c // a\n\n\n:=\n海象运算符Python3.8 版本新增运算符。\n可在表达式内部为变量赋值，例如：if (n := len(a)) &gt; 10:print(f\"List is too long ({n} elements, expected &lt;= 10)\")\n\n\n1.2.2 浮点数 float带小数点的数字称为浮点数。\n其计算方式几乎与整数相同。\n1.2.3 Bool数 bool两个 Bool 数True与False，值分别为1和0。\n1.2.4 复数 complex用a+bj或者complex(a,b)表示复数：\n1.3 列表用[]括起来的元素的有序排列，元素之间用,隔开。\n1.3.1 列表的索引列表元素的索引从0开始：列表名[索引]\n最后一个列表元素可用索引 -1 来指定，\n倒数第二个列表元素可用索引 -2 来指定……\n以此类推\n1.3.2 列表的方法\n\n\n方法\n返回\n注释\n\n\n\nlist.append(obj)\nNA\n列表末尾附加元素obj\n\n\nlist.insert(index,obj)\nNA\n列表索引为index处插入元素obj\n\n\ndel list[index]\nNA\n列表中直接删除索引为index的元素，严格意义上不算作方法\n\n\nlist.pop([index=-1])\n列表中索引为index的元素\n同时删除该元素\n\n\nlist.remove(obj)\nNA\n删除列表中第一个遇到的obj\n\n\nlist.count(obj)\n列表中obj出现的次数\n\n\n\nlist.index(obj)\n列表中第一个遇到的obj的索引\n\n\n\nlist.reverse()\nNA\n列表元素倒序排列\n\n\nlist.sort([cmp],key,reverse)\nNA\n根据三个参数进行排序，默认升序\n\n\nlist.copy()\n列表的浅复制\n相当于list[:]\n\n\nlist.clear()\nNA\n清空列表\n\n\n1.3.3 列表的函数\n\n\n函数\n返回\n\n\n\nlen(list)\n列表元素的个数\n\n\nmax(list)\n列表元素的最大值\n\n\nmin(list)\nNA\n\n\nrange([start=0],stop,[step=1])\n从start开始，到stop之前的，步长为step的整数列表\n\n\n可用sorted(list)进行列表排序返回排序列表但不改变列表原顺序\n1.3.4 遍历列表通常使用for...in...循环：\nfor item in items:    print('冒号不能丢！')\n\n\n技巧：列表解析 例如\nprint([integer**3 for integer in range(1,11)])\n\n直接打印出1-10的立方列表。\n\n1.3.5 列表的切片list[[index1=0]:[index2]:[step=1]]\n\n将list中索引从index1到index2-1之间的元素以step为步长提取出来组成一个新的列表（取头不取尾），若step为负则表示逆向读取。\nindex1省略则从头开始，index2省略则直到末尾，step省略则默认为1，特别地得到：\n\n技巧：复制列表 例如\nlist2=list1[:]\n\n就将list1复制为list2。\n直接赋值的话会让这两个变量都指向同一个列表，因而是不行的。\n\n1.3.6 列表的其他操作\n\n列表可用*连接某个整数来翻倍：\n\n [1,2]*2如相当于[1,2,1,2]\n\n两个列表可用+来拼接：\n\n 如[1,2]+[3,4]相当于[1,2,3,4]\n\n1.4 元组不可变的列表称为元组，用()而不是[]进行标识。\n虽然元组不可变，但是可以重新给元组变量赋值，例如：\ncoordinates=(1,2)coordinates=(3,4)\n\n构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：\ntup1 = ()    # 空元组tup2 = (20,) # 一个元素，需要在元素后添加逗号\n\n1.5 集合无序的不重复元素序列称为集合，用{}来标识。可以用{}或者set()来创建集合。但是空集合只能用set()创建。\n集合的运算：\na - b # a与b的差集a | b # a与b的并集a &amp; b # a与b的交集a ^ b # a与b不同时存在的元素\n\n\n\n1.6 字典Python中的字典是一系列无序的 key-value 对，每一个 key 都与其对应的 value 相关联，用{}来标识，对与对之间用逗号,来分隔，key 与 value 之间用冒号:连接\nvalue 可以是任何对象，但 key 有一定的限制：\n\n\n同一个 key 不允许出现两次，如果出现多次，只会记住后面 key 的 value\nkey 只能是不可变类型数据\n\n\n函数dict()可构建字典如下：\n&gt;&gt;&gt;dict()                        # 创建空字典{}&gt;&gt;&gt; dict(a='a', b='b', t='t')     # 传入关键字{'a': 'a', 'b': 'b', 't': 't'}&gt;&gt;&gt; dict(zip(['one', 'two', 'three'], [1, 2, 3]))   # 映射函数方式来构造字典{'three': 3, 'two': 2, 'one': 1} &gt;&gt;&gt; dict([('one', 1), ('two', 2), ('three', 3)])    # 可迭代对象方式来构造字典{'three': 3, 'two': 2, 'one': 1}\n\n1.6.1 访问和修改字典中的值按如下语句访问dictionary中与key关联的value：\nvalue = dictionary[key]\n\n按如下语句修改dictionary中与key关联的value：\ndictionary[key]=new_value\n\n1.6.2 添加和删除 key-value 对按如下语句添加dictionary中的 key-value 对：\ndictionary[new_key]=new_value\n\n按如下语句删除dictionary中的 key-value 对：\ndel dictionary[key]\n\n1.6.3 字典的方法\n\n\n方法\n返回\n注释\n\n\n\ndict.clear()\nNA\n清空字典\n\n\ndict.copy()\n字典复制\n类似于list[:]\n\n\ndict.get(key,[default=None])\n指定key的 value，如果key不存在返回 default值\n避免直接引用值出错\n\n\ndict.items()\nkey-value 对的元组列表\n\n\n\ndict.keys()\n字典所有 key 的列表\n\n\n\ndict.setdefault(key,[default=None])\n指定key的 value，如果key不存在就添加，将其 value 设置为default，并返回之\n\n\n\ndict.update(dict2)\nNA\n把dict2中的 key-value 对添加到dict中\n\n\ndict.pop(key,[default])\n提取出key对应的 value，如果无则返回default值\n同时在dict中删除该对\n\n\ndict.popitem()\n字典的最后一个 key-value 对的元组\n同时在dict中删除该对\n\n\n1.6.4 遍历字典\n遍历 key-value 对：\nfor key,value in dict.items()\n遍历 key：\nfor key in dict.keys()\n\n或更简单地：\nfor key in dict\n遍历 value：\nfor value in dict.values()\n\n若要避免重复，可用set()函数\n\n\n1.7 数据类型转换有时候，我们会使用某些函数对数据内置的类型进行转换，这些函数的函数名就是对应的数据类型名：\n\n\n\n函数\n注释\n\n\n\nint(x,[base=10])\n将x转换为一个以base为进制单位的整数\n\n\nfloat(x)\n将x转换到一个浮点数\n\n\ncomplex(real,[imag=0])\n创建一个复数\n\n\nstr(x)\n将对象x转换为字符串\n\n\nrepr(x)\n将对象x转换为表达式字符串\n\n\neval(expression[, globals[, locals]])\n用来计算在字符串expression中的有效Python表达式,并返回一个对象\n\n\ntuple(s)\n将序列s转换为一个元组\n\n\nlist(s)\n将序列s转换为一个列表\n\n\nset(s)\n将s转换为可变集合\n\n\ndict(d)\n创建一个字典。d必须是一个 (key, value)元组序列。\n\n\nfrozenste(s)\n转换为不可变集合\n\n\nchr(x)\n将整数x转换为对应的 ASCII 字符\n\n\nord(x)\n将 ASCII 字符x转换为它对应的整数值\n\n\nhex(x)\n将整数x转换为其十六进制字符串形式\n\n\noct(x)\n将整数x转换为其八进制字符串形式\n\n\n2 if语句和while循环一般格式：\nif condition_1:    print('冒号不能丢！')elif condition_2:    print('冒号不能丢！')elif condition_3:    ...elif condition_N:    print('冒号不能丢！')else:    print('冒号仍然不能丢！')\n\n2.1 逻辑运算下面所有的例子的结果都为True：\n\n\n\n运算符\n例子\n注释\n\n\n\n==\n1==1\n判等\n\n\n!=\n1!=2\n判不等\n\n\n&gt;\n3&gt;2\n判大于\n\n\n&lt;\n2&lt;3\n判小于\n\n\n&gt;=\n3&gt;=2\n判大于等于\n\n\n&lt;=\n2&lt;=3\n判小于等于\n\n\nand\nTrue and True\n与\n\n\nor\nTrue or False\n或\n\n\nnot\nnot False\n非\n\n\nin\n1 in [1,2]\n判包含\n\n\nnot in\n3 not in [1,2]\n判不包含\n\n\nis\na=[1,2] b=a a is b\n判地址相同\n\n\nis not\na=[1,2] b=[1,2] a is not b\n判地址不同\n\n\n在 Python 中，除了以下这些表示都意味着False外，其他都是True：\nFalse0''[]{}None\n\n2.2 while循环while语句按如下方式使用：\nwhile condition:    print('冒号也不能丢！')\n\n下面列出了三种在if语句、for...in...循环和while循环中常常使用的语句：\n\n\n\n语句\n注释\n\n\n\nbreak\n退出break所在的最内层的循环\n\n\ncontinue\n跳过一次continue所在的最内侧的循环\n\n\npass\n什么都不做，仅仅用来占位\n\n\n3 函数函数是带名字的打包好的代码块：\ndef functionname([parameters]):    \"\"\"函数文档字符串（冒号仍然不能丢！）\"\"\"    function_suite    return [expression]\n\n如果return不带表达式或者没有return则默认返回None。\n如果return返回多个值则需要用,分隔，返回的数据类型是元组。\n3.1 函数的参数实际调用函数时，输入的实参可用与形参相同的位置表明对应关系，也可用形参的名字来表明对应关系。\n在定义函数时，可以给参数设定默认值，这些参数就变成可选的，如：\ndef functionname(game_name='塞尔达传说——旷野之息'):    \"\"\"我最想玩的游戏\"\"\"    print(\"我最想玩的游戏是\"+game_name)    return\n\n在有多个形参时，先列出没有默认值的参数，再列出有默认值的。\n给函数传递列表或字典可对列表和字典进行修改。若要防止函数修改列表可传递列表的副本list[:]或字典的副本dict.copy()\n有时候可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述参数不同，声明时不会命名，因此放在参数列表末尾。基本语法如下：\ndef functionname([formal_args] *var_args_tuple ):   \"\"\"函数_文档字符串\"\"\"   function_suite    return [expression]\n\n例如：\n&gt;&gt;&gt; def printtuple(*my_game):&gt;&gt;&gt;     print(my_game)&gt;&gt;&gt;     return&gt;&gt;&gt; printtuple('塞尔达传说——旷野之息','围棋',\"Don't Starve\")('塞尔达传说——旷野之息', '围棋', \"Don't Starve\")\n\n加了星号*的参数会以元组的形式导入，存放所有未命名的变量参数。\n另外一种情形是加两个星号**的不定长参数，这时的参数会以字典的形式导入：\ndef functionname([formal_args,] **var_args_dict ):   \"函数_文档字符串\"   function_suite   return [expression]\n\n例如：\n&gt;&gt;&gt; def printdict(**my_love):&gt;&gt;&gt;     print(my_love)&gt;&gt;&gt;     return&gt;&gt;&gt; printdict(她='三三',事业='物理',爱好='数学、天文学、编程',游戏='塞尔达传说——旷野之息'){'她': '三三', '事业': '物理', '爱好': '数学、天文学、编程', '游戏': '塞尔达传说——旷野之息'}\n\n3.2 导入模块中的函数将函数打包储存在模块中常常是有好处的，可以让函数的使用和修改都变得极为方便。\n3.2.1 导入整个模块直接使用import语句：\nimport module1[, module2[,... moduleN]\n\n相当于把另一个源文件的内容都复制进这个程序文件中。在使用另一个源文件的函数时需要用句点.把模块名和函数名分隔开来：\nimport modulemodule.printHello()\n\n3.2.2 导入模块中特定的函数示例如下：\nfrom module import function_1,function_2function_1()function_2()\n\n这样使用函数时就直接引用函数名而无需指定模块名。\n3.2.3 使用as给函数指定别名通常是为了使用方便或者为了避免函数重名。示例如下：\nfrom module import function as f\n\n3.2.4 使用as给模块指定别名通常是模块名太长为了简化：\nimport module as mm.function()\n\n3.2.5 导入模块中所有的函数和变量使用*运算符：\nfrom module import *\n\n但这样可能会导致函数和变量重名的问题\n3.2.6 模块内置__name__属性一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。\n# Filename: using_name.pyif __name__ == '__main__':   print('程序自身在运行')else:   print('我来自另一模块')\n\n运行输出如下：\n$ python using_name.py程序自身在运行$ python&gt;&gt;&gt; import using_name我来自另一模块\n\n每个模块都有一个__name__属性，当其值是'__main__'时，表明该模块自身在运行，否则是被引入。\n注意：__name__ 与 '__main__' 底下是双下划线。\n3.2.7 dir()函数函数dir() 可以找到模块内定义的所有名称，以一个字符串列表的形式返回：\n&gt;&gt;&gt; import time&gt;&gt;&gt; dir(time)['_STRUCT_TM_ITEMS', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'altzone', 'asctime', 'clock', 'ctime', 'daylight', 'get_clock_info', 'gmtime', 'localtime', 'mktime', 'monotonic', 'monotonic_ns', 'perf_counter', 'perf_counter_ns', 'process_time', 'process_time_ns', 'sleep', 'strftime', 'strptime', 'struct_time', 'thread_time', 'thread_time_ns', 'time', 'time_ns', 'timezone', 'tzname']\n\n如果没有给定参数，那么dir()函数会罗列出当前模块定义的所有名称。\n&gt;&gt;&gt; a = 1&gt;&gt;&gt; game=[\"塞尔达传说——旷野之息\",\"围棋\",\"Don't Starve\"]&gt;&gt;&gt; def printHello():    print(\"Hello,world!\")&gt;&gt;&gt; dir()['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'game', 'printHello']\n\n3.3 匿名函数Python 使用lambda来创建匿名函数。\n所谓匿名，意即不再使用def语句这样标准的形式定义一个函数。\n\nlambda 只是一个表达式，函数体比 def 简单很多。\nlambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。\nlambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。\n\nlambda 函数的语法只包含一个语句，如下：\nlambda [arg1,arg2,.....argn]:expression\n\n例如：\nsum = lambda arg1, arg2: arg1 + arg2 # 调用sum函数print (\"相加后的值为 : \", sum( 10, 20 ))print (\"相加后的值为 : \", sum( 20, 20 ))\n\n\n\n4 类4.1 面向对象技术简介\n\n类（Class）: 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。\n方法：类中定义的函数。\n类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。\n数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。\n方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。\n局部变量：定义在方法中的变量，只作用于当前实例的类。\n实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。\n继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个 Dog 类型的对象派生自 Animal 类，这是模拟”是一个（is-a）”关系（例图，Dog 是一个 Animal）。\n实例化：创建一个类的实例，类的具体对象。\n对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。\n\n\n和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。\nPython中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。\n对象可以包含任意数量和类型的数据。\n4.2 创建类使用class语句来创建一个新类，class之后为类的名称（首字母一般要大写）并以冒号结尾：\nclass ClassName:   '类的帮助信息'    #类文档字符串   class_suite     #类体\n\n类的帮助信息可以通过ClassName.__doc__查看。\nclass_suite由类成员，方法，数据属性组成。\n例子：\nclass Dog():    \"\"\"Simulate the puppy\"\"\"        def __init__(self,name,age):        \"\"\"Initialize properties\"\"\"        self.name = name        self.age = age            def sit(self):        \"\"\"Simulate the puppy sitting down\"\"\"        print(self.name+\"坐下\")        my_dog = Dog('包包',3)my_dog.sit()\n\n4.3 类的属性与方法4.3.1 类的私有属性__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。\n4.3.2 类的方法在类的内部，使用def关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数self，且为第一个参数，self代表的是类的实例。\nself的名字并不是规定死的，也可以使用this，但是最好还是按照约定是用 self。\n4.3.3 类的私有方法__private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。\n类有一个名为 __init__()的特殊方法（构造方法），该方法在类实例化时会自动调用，像下面这样：\ndef __init__(self):    self.data = []\n\n__init__()方法可以有参数，参数通过__init__()传递到类的实例化操作上\nclass Test:    def prt(self):        print(self)        print(self.__class__) t = Test()t.prt()\n\n以上实例执行结果为：\n&lt;__main__.Test object at 0x00000136A4503788&gt;&lt;class '__main__.Test'&gt;\n\n从执行结果可以很明显的看出，self代表的是类的实例，代表当前对象的地址，而self.__class__则指向类。\nself不是 Python 关键字，将其换成其他名字也是可以的\n4.4 类的继承有时候创建类时它只是现有某个类的特殊版本，这时候就能让它（子类）继承原有类（父类）的方法和属性：\nclass Dog():    \"\"\"Simulate the puppy\"\"\"        def __init__(self,name,age):        \"\"\"Initialize properties\"\"\"        self.name = name        self.age = age            def sit(self):        \"\"\"Simulate the puppy sitting down\"\"\"        print(self.name+\"坐下\")        class FrenchBullDog(Dog):    \"\"\"Simulate the french bulldog\"\"\"    def __init__(self,name,age,weight):        super().__init__(name,age)        self.weight = weightmy_dog = FrenchBullDog('包包',3,20)my_dog.sit()\n\n创建子类时，父类必须包含在当前文件中，且位于子类前面。定义子类时，必须在括号内指定父类的名称。\nsuper()是一个特殊函数，帮助 Python 将父类（superclass）与子类联系起来。\n4.4.1 类的方法的重写如果父类的方法不能满足子类的需要，可以在子类中使用同名的方法来覆盖它：\nclass Dog():    \"\"\"Simulate the puppy\"\"\"        def __init__(self,name,age):        \"\"\"Initialize properties\"\"\"        self.name = name        self.age = age            def sit(self):        \"\"\"Simulate the puppy sitting down\"\"\"        print(self.name+\"坐下\")        class FrenchBullDog(Dog):    \"\"\"Simulate the french bulldog\"\"\"    def __init__(self,name,age,weight):        super().__init__(name,age)        self.weight = weight    def sit(self):        print(self.name+\"乖乖地坐下\")my_dog = FrenchBullDog('包包',3,20)my_dog.sit()\n\n4.5 将实例用作属性可以在大类中用小类作为属性：\nclass Hair():    def __init__(self,color,length,shape):        self.color = color        self.length = length        self.shape = shapeclass Dog():    \"\"\"Simulate the puppy\"\"\"        def __init__(self,name,age,color,length,shape):        \"\"\"Initialize properties\"\"\"        self.name = name        self.age = age        self.hair = Hair(color,length,shape)    def describe(self):        print(self.name+'是一只'+str(self.age)+'岁的小狗，他的毛是'+self.hair.color+'色的，而且又'+self.hair.length+'又'+self.hair.shape)        my_dog = Dog('包包',3,'棕','短','直')my_dog.describe()\n\n\n\n5 文件Python 使用open()函数来打开文件并返回文件对象，其具体语法如下：\n完整的语法格式为：\nopen(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)\n\n参数说明:\n\nfile: 必需，文件路径（相对或者绝对路径），注意 Windows 系统用的是反斜杠\\而不是斜杠/。\nmode: 可选，文件打开模式\nbuffering: 设置缓冲\nencoding: 一般使用 utf8\nerrors: 报错级别\nnewline: 区分换行符\nclosefd: 传入的file参数类型\nopener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。\n\n如果文件无法按指定模式打开，会抛出OSError。\nmode 参数有：\n\n\n\n模式\n注释\n\n\n\nt\n文本模式\n\n\nx\n写模式，新建一个文件，如果该文件已存在则会报错\n\n\nb\n二进制模式\n\n\n+\n打开一个文件进行更新（可读可写）\n\n\nr\n以只读方式打开文件。文件的指针在文件开头\n\n\nrb\n以r方式和二进制模式打开文件，一般用于非文本文件如图片\n\n\nr+\n打开一个文件用于读写。文件指针在文件开头\n\n\nrb+\n以r+方式和二进制模式打开文件，一般用于非文本文件如图片\n\n\nw\n打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件\n\n\nwb\n以w方式和二进制模式打开文件，一般用于非文本文件如图片\n\n\nw+\n打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。\n\n\nwb+\n以w+方式和二进制模式打开文件，一般用于非文本文件如图片\n\n\na\n打开一个文件用于追加。如果该文件已存在，文件指针在文件结尾。如果该文件不存在，创建新文件进行写入。\n\n\nab\n以a方式和二进制模式打开文件，一般用于非文本文件如图片\n\n\na+\n打开一个文件用于读写。如果该文件已存在，文件指针在文件结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。\n\n\nab+\n以a+方式和二进制模式打开文件，一般用于非文本文件如图片\n\n\n5.1 文件对象的方法\n\n\n方法\n返回\n注释\n\n\n\nfile.close()\nNA\n关闭文件\n\n\nfile.flush()\nNA\n刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。\n\n\nfile.read([size=-1])\n读取的内容\n从文件读取指定为size的字节数，如果为负则读取所有。\n\n\nfile.readline([size=-1])\n读取的内容\n从文件一行读取指定为size的字节数，如果为负则读取所有，包括 '\\n' 字符。\n\n\nfile.readlines()\n文件的每一行的列表\n读取全文件，返回行列表\n\n\nfile.seek(offset,[ whence=0])\n如果操作成功，则返回新的文件位置，如果操作失败，则返回 -1。\noffset为位移量，whence为指定位置，0为当前位置，1为从文件开始算起，2为从文件末尾算起\n\n\nfile.tell()\n返回文件指针的当前位置\n返回值是从开头算起的字节数\n\n\nfile.write([str])\n写入文件的字符串长度\n在文件中写入给定的字符串，在文件关闭前或缓冲区刷新前，字符串内容存储在缓冲区中。如果文件打开模式带b，那写入文件内容时，str要用encode()方法转为 bytes 形式，否则报错。\n\n\nfile.writelines(sequence)\nNA\n向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。\n\n\n6 迭代器和生成器6.1 迭代器迭代器(iter)是一个可以记住遍历的位置的对象。\n迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。\n迭代器有两个基本的方法：iter() 和 next()。\n字符串，列表或元组对象都可用于创建迭代器：\n&gt;&gt;&gt; list=[1,2,3,4]&gt;&gt;&gt; it = iter(list)   # 创建迭代器对象&gt;&gt;&gt; print (next(it))  # 输出迭代器的下一个元素1&gt;&gt;&gt; print (next(it))2\n\n迭代器对象可以使用常规for语句进行遍历：\nlist=[1,2,3,4]it = iter(list)    # 创建迭代器对象for x in it:    print (x, end=\" \")\n\n也可以使用 next() 函数：\nimport sys         # 引入 sys 模块 list=[1,2,3,4]it = iter(list)    # 创建迭代器对象 while True:    try:        print (next(it))    except StopIteration:        sys.exit()\n\n把一个类作为一个迭代器使用需要在类中实现两个方法__iter__()与__next__()。\n\n__iter__()方法返回一个特殊的迭代器对象， 这个迭代器对象实现了__next__() 方法并通过StopIteration异常标识迭代的完成。\n__next__()方法会返回下一个迭代器对象。\n\n例如一个返回 Fibbonacci 数列的迭代器：\nclass FibbonacciSequence():    def __iter__(self):        self.n = 1        self.f_1 = 1        self.f_2 = 1        return self\t    def __next__(self):        if self.n &lt;= 10:            temp = self.f_1            self.f_1,self.f_2 = self.f_2,self.f_1+self.f_2            self.n += 1            return temp        else:            raise StopIterationmy_fibbonacci = FibbonacciSequence()my_iter = iter(my_fibbonacci) for number in my_iter:\tprint(number)\n\n6.2 生成器在 Python 中，使用了yield的函数被称为生成器（generator）。\n生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。\n在调用生成器运行的过程中，每次遇到yield时函数会暂停并保存当前所有的运行信息，返回yield的值, 并在下一次执行next()方法时从当前位置继续运行。\n例如将上面的代码改写为：\ndef fibbonacci_sequence(n):    count = 1    f_1 = 1    f_2 = 1        while True:        if count &gt; n:            return        yield f_1        f_1, f_2 = f_2, f_1 + f_2        count += 1        my_fibbonacci = fibbonacci_sequence(10)for number in my_fibbonacci:    print(number)\n","tags":["笔记"]},{"title":"熬夜","url":"/2021/03/22/%E7%86%AC%E5%A4%9C/","content":"尽管我深刻地知道熬夜无论是对身体还是对精神，从长远来讲都是不健康的，但是最近我还是难以避免自己内心的冲动去熬夜。\n今晚又熬到快两点，为的就是找一个能作为自己网站壁纸的塞尔达动态图或者风景图。结果图没找到，好的 webm 视频却找到了，真是太美了！我什么时候才能自己做出这样的图啊！\n但遗憾的是，webm 是 HTML5 的视频格式，并不能作为网站的背景封面使用。相反，我尝试着导出 gif 文件，结果好生生的一个 2M 多的文件硬是转成了 71M，看来信息革命势在必行啊。\n令人宽慰的是，隔壁王志远也在为写一篇英语作业而 stay up late，而其文章的题目居然就是 Don’t stay up late！清华学生行胜于言的好风气都到哪儿去了？Actions speak louder than words！\n不说了，我得去 Action 了。\n晚安，希望明天早上不会起太迟，还有作业要写。\n附注：由于自己今晚的瞎折腾，网站又重新建了一遍，不然上传贼慢。以后不要贪婪地乱做大改动了吧。\n","tags":["熬夜"]},{"title":"这三天","url":"/2021/03/20/%E8%BF%99%E4%B8%89%E5%A4%A9/","content":"记得是18号那天偶然搜到了一个人在 bookdown 上写的数学笔记，然后联想到这一段时间自己在 iPad 上大量“引用”数学、物理的经典书籍来整理自己的知识系统（我现在还很讨厌用系统这个词，有一种泯灭个性和变化的感觉在里面)，突然发现这就是我想要的啊！就像艺术家做出自己的艺术作品一样，我并不是特别在乎我写的这些东西有没有人看。毫无疑问，我写这些东西的首要目的是愉悦我自己。\n然后我了解到这是谢益辉利用 Rmarkdown 制作的专门用来写书的网站，不仅如此，Rmarkdown 还可以拿来写博客，这无疑又满足了我的一个愿望：记录自己的生活和想法，并且完全是在自己的空间里，不必为什么人会看到而考虑。虽说日记也有这样的功能吧，但是我自己就是不太习惯用笔来写日记，因为在信息时代，将东西写在纸上至少有一下四个缺点：\n\n不方便保存，弄不好就找不到了\n不方便修改，如果硬要用修改符号的话可能会被迫治好我的强迫症，但也只是可能而已，半途而废是可以预料的结果\n不方便查阅，时间久了，自己都不知道自己写了些什么东西\n写的过程中怕被别人看见自己的一些不成熟的想法，自己的字也不是特别好看\n\n而用 markdown 进行书写并上传到自己的网站上可完美解决这些个缺点。于是 3.18 那天，我捣鼓了一天的 Rstudio 和 Rmarkdown，最后被 Rmarkdown 导出 pdf 文件的一些个 bug 弄得死去活来，晚上一点才睡觉。\n3.19 早上，我用游泳课的时间将电脑挂在那重装了 texlive，完美解决了导出 pdf 文件的问题。至少以后都可以拿这个来写报告了。\n但是人在面对自己喜欢的事情时总是会情不自禁得得陇望蜀，Gauss 好像说过一句名言，大意是他之所以乐此不疲地搞数学研究，是因为每攻克一个难题就像古代的将军攻克一座城市一样，会有一种发自内心的快乐。我弄好了本地 Rmarkdown 配置后，又得寸进尺地想着自己是不是也可以像谢益辉那样建立自己的网站呢？通过一番攻略之后，我了解了大概的步骤，但是奈何计算机不像数学、物理，搞懂逻辑就能推演出来，实际的情况往往是：书上说的好好的，自己运行的时候总是有一堆莫名奇妙的 bug。在尝试了各种方法之后，已是强弩之末的我不得不选择了放弃，在有各种 ddl 逼身的情况下，玩起了塞尔达。这天刚好又是星期五，晚上不熄灯，室友们王者开黑乐此不疲，我一开始想着玩到十一点就睡吧，但还是抵御不了海拉鲁大陆的诱惑，一打就是两点。\n3.20 一起床，我就找到了一篇宝贵的制作个人网站的教程：EasyHexo。相比于其他教程，这一套居然有视频！我在视频的引导下，虽然也出现了不少问题，但幸运的是到下午三四点的时候基本上都解决了，最后做成了自己的个人网站（当然，这个域名还是要点钱的）。\n这几天都在忙自己的活，也不是很照顾到三三宝贝，她已经上车了，我们明天就可相见，当然不会忘了给她带好吃的。\n这是第一篇博客，关于写文章的事情，我会在有空的时候做出一些说明。\n这几天就这样吧，今天得早睡了，晚安哟！\n","tags":["生活"]},{"title":"速通","url":"/2021/03/22/%E9%80%9F%E9%80%9A/","content":"昨天晚上睡觉前居然该死地打开了 B 站，莫名奇妙地看到了一个塞尔达的速通视频。那人居然只用二十七八分钟就通关了塞尔达，其中利用了诸如穿墙、盾牌弹射、静止器弹射等诸多技巧，甚至可以说是游戏的 bug。然而，我看完时那种震惊感在今天早上继续看了一些视频之后几乎消失了，因为这些速通演示无一例外地都把通关塞尔达程序化了：先干 A，再干 B，干 A 与干 B 之间如果干 C 的话能节约多少多少秒。诸如此类的算计让这款游戏变得没有人性，看视频的时候就觉得各种 NPC 只是游戏浪费时间的设定，各种过场动画也可有可无，那样玩游戏是为了什么呢？就是为了这二十几分钟的通关吗？与之类似的各种攻略也是一样，虽然通过查攻略，看起来我们轻而易举地就学到很多实用技巧，大大提升了自己玩游戏的技术，但是同时也损失了自己筚路蓝缕的乐趣，而开放式探索游戏最重要的不就是这一点吗？\n无论是速通还是查攻略，可能都存在想快速获得快乐的想法在其中，而效率与乐趣常常是相互矛盾的。我很喜欢李松蔚说过的一句话：如果在一件事情上追求速度，那就说明我们在某种程度上对这件事情的过程感到厌烦。无论是快速读书、快速学习、快速通关都是如此，这件事情本身的乐趣被我们对结果的追求极大地消解了，虽然在达到目的、看到成果的那一刹那我们可能会欣喜若狂，但伴随而来的将是漫长的空虚与麻木的感觉。在某种程度上，麻木比负面情绪更可怕，因为这代表我们已经失去了感知能力，NPC 对我们来说是浪费时间，Boss 对我们来说只是蹂躏的对象，蘑菇、苹果只是为达到目的而必须准备的材料罢了。\n前段时间研究围棋就想到，如果一开始就跟着 AlphaGo Zero 去学习，那我不是可以迅速变成大神？结果看了 Zero 的棋，发现这不是人能下出来的，Zero 太精于算计了、太冷静了，它有一个最终目的在那：赢棋，以及更有效率地稳定赢棋。人当然也有追求效率和稳定的需求，这是人的理性，但人不能过度追求效率和稳定， 成为所谓的大神，因为这意味着我们失去了人性（失去人性到底是好是坏我不清楚，但我或多或少有些反感），就跟《诗云》中的李白差不多。我们虽然能通过汉字的排列组合写出世界上所有的诗，但写诗难道就是为了写出诗吗？难道不觉得为写诗而“拈断数茎须”的经历更值得回味吗？\n我不能一直抨击效率，毕竟效率也给我们的生活带来了诸多方便。追求效率，应是工业时代和信息时代的产物。工业化生产要求人们能按质按量地重复生产某一产品或达到某一目的，信息化方便人们快速获得咨询，省去了自己探索的时间，用更快的速度学到更多的东西，确实可以让更多的人过上更好的日子。但我们要看到，一方面，我们追求效率地完成任务，另一方面，我们又在追求效率伴随而来的空虚中“浪费时间”。我们本能地反抗效率，却又毫无止境地追求效率，我不知道这是好还是坏，但我总觉得少了某些田园诗般的闲适和充实，取而代之的是紧张、焦虑和空虚。虽说人类可能天生就喜欢折腾，但我们更喜欢在自己设定的规则里去折腾，不知道这是不是一种自我欺骗。或许是不是也都没意义了，因为许多人在这种自我欺骗中乐此不疲呢，而且，难道我喜欢的事情就不是另一种形式的自我欺骗吗？\n说了这么多废话（这貌似也是一个追求效率的词吧），我想我可以把 iPad 上存有塞尔达攻略的 App 删掉了吧。\n","tags":["游戏 生活"]}]